<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>foliationSimulation &mdash; foliation-sim 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> foliation-sim
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">foliation-sim</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">foliation-sim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Module code</a> &raquo;</li>
      <li>foliationSimulation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for foliationSimulation</h1><div class="highlight"><pre>
<span></span><span class="c1"># -----------------------------------------------------------</span>
<span class="c1"># Simulates the dn = 0 evolution from an initial surface in 2 dimensions</span>
<span class="c1"># for an Euclidean and Minkowski metric.</span>
<span class="c1">#</span>
<span class="c1"># (C) 2022 Florian Babisch, TÃ¼bingen, Germany</span>
<span class="c1"># Released under CC-BY license</span>
<span class="c1"># email flofe@t-online.de</span>
<span class="c1"># -----------------------------------------------------------</span>

<span class="c1"># This code uses the numpy convention for docstrings</span>

<span class="kn">from</span> <span class="nn">cmath</span> <span class="kn">import</span> <span class="n">inf</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">LinearLocator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sy</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">ipywidgets</span> <span class="kn">import</span> <span class="n">interact</span><span class="p">,</span> <span class="n">interactive</span><span class="p">,</span> <span class="n">fixed</span><span class="p">,</span> <span class="n">interact_manual</span><span class="p">,</span> <span class="n">IntSlider</span><span class="p">,</span> <span class="n">HBox</span><span class="p">,</span> <span class="n">VBox</span><span class="p">,</span> <span class="n">Layout</span><span class="p">,</span> <span class="n">Dropdown</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">clear_output</span>
<span class="kn">import</span> <span class="nn">ipywidgets</span> <span class="k">as</span> <span class="nn">widgets</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">colors</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>

<span class="c1"># SymPy symbols</span>
<span class="c1"># In the following x cannot be used as a variable for anything else!</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

<span class="c1"># Global figure</span>
<span class="c1"># Set sharex to False if you want to save an image of only the first axis</span>
<span class="c1"># Set it to True if you want to have both plots use the same axis</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Class is not written by me, source: </span>
<span class="c1"># https://stackoverflow.com/questions/13054758/python-finding-multiple-roots-of-nonlinear-equation</span>
<div class="viewcode-block" id="ClassRoots"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.ClassRoots">[docs]</a><span class="k">class</span> <span class="nc">ClassRoots</span><span class="p">:</span>
    <span class="c1"># binary search</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="ClassRoots.rootsearch"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.ClassRoots.rootsearch">[docs]</a>    <span class="k">def</span> <span class="nf">rootsearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">dx</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">dx</span><span class="p">;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">f1</span><span class="o">*</span><span class="n">f2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">dx</span><span class="p">;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x1</span><span class="p">,</span><span class="n">x2</span></div>

<div class="viewcode-block" id="ClassRoots.bisect"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.ClassRoots.bisect">[docs]</a>    <span class="k">def</span> <span class="nf">bisect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">switch</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">epsilon</span><span class="o">=</span><span class="mf">1.0e-9</span><span class="p">):</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f1</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x1</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f2</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x2</span>
        <span class="k">if</span> <span class="n">f1</span><span class="o">*</span><span class="n">f2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c1">#print(&#39;Root is not bracketed&#39;)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">/</span><span class="n">epsilon</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">);</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x3</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">switch</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f3</span><span class="p">)</span> <span class="o">&gt;</span><span class="nb">abs</span><span class="p">(</span><span class="n">f1</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f3</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f2</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">f3</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x3</span>
            <span class="k">if</span> <span class="n">f2</span><span class="o">*</span><span class="n">f3</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">x3</span>
                <span class="n">f1</span> <span class="o">=</span> <span class="n">f3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x2</span> <span class="o">=</span><span class="n">x3</span>
                <span class="n">f2</span> <span class="o">=</span> <span class="n">f3</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span></div>

<div class="viewcode-block" id="ClassRoots.roots"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.ClassRoots.roots">[docs]</a>    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
        <span class="c1">#print (&#39;The roots on the interval [%f, %f] are:&#39; % (a,b))</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootsearch</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">x2</span>
                <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="c1">#print (round(root,-int(math.log(eps, 10))))</span>
                    <span class="n">zeros</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="mi">10</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#print(zeros)</span>
                <span class="c1">#print (&#39;\nDone&#39;)</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">zeros</span></div></div>

<div class="viewcode-block" id="isfloat"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.isfloat">[docs]</a><span class="k">def</span> <span class="nf">isfloat</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if input is float or not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input : any</span>
<span class="sd">            Input that is analyzed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        boolean</span>
<span class="sd">            Tells whether the input is float or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="transform_function"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.transform_function">[docs]</a><span class="k">def</span> <span class="nf">transform_function</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transforms expression of a function into a numpy expression and returns two lists of values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-coordinates.</span>
<span class="sd">        func: SymPy type</span>
<span class="sd">            Function that is to be evaluated at the given x-coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The x-coordinates and the function evaluated at the coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isfloat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">npFunc</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xValues</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">xValues</span><span class="p">,</span> <span class="n">npFunc</span>
    <span class="n">npFunc</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xValues</span><span class="p">,</span> <span class="n">npFunc</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span></div>


<div class="viewcode-block" id="transform_vector"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.transform_vector">[docs]</a><span class="k">def</span> <span class="nf">transform_vector</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transforms tuple of sympy expressions into a tuple of numpy expression and evaluates at the</span>
<span class="sd">       given x-coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-coordinates.</span>
<span class="sd">        vector : tuple</span>
<span class="sd">            Vector with two components that is to be evaluated at the given x-coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple </span>
<span class="sd">            Components of the vector evaluated at the given x-coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xValues</span><span class="p">,</span> <span class="n">v0</span> <span class="o">=</span> <span class="n">transform_function</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
    <span class="n">xValues</span><span class="p">,</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">transform_function</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span></div>


<div class="viewcode-block" id="euclidean_normal_vector"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.euclidean_normal_vector">[docs]</a><span class="k">def</span> <span class="nf">euclidean_normal_vector</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates normal vector with Euclidean metric.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function of which the normal vector is calculated.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple </span>
<span class="sd">           Normal vector of given function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">funcPrime</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">funcPrime</span><span class="p">,</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="minkowski_normal_vector"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.minkowski_normal_vector">[docs]</a><span class="k">def</span> <span class="nf">minkowski_normal_vector</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates normal vector with Minkowski metric.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function of which the normal vector is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Normal vector of given function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">funcPrime</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">funcPrime</span><span class="p">,</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="euclidean_normal_values"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.euclidean_normal_values">[docs]</a><span class="k">def</span> <span class="nf">euclidean_normal_values</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create x- and y-values for the Euclidean normal vector of the given function.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-coordinates.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function for which the values of the unit normal vectors are created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple </span>
<span class="sd">            The x- and y-values of the normal vector of the given function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span>
    <span class="c1"># check if function is constant</span>
    <span class="k">if</span> <span class="n">isfloat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">xComponent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">)]</span>
        <span class="n">yComponent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">)]</span>
        <span class="n">xComponent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xComponent</span><span class="p">)</span>
        <span class="n">yComponent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yComponent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xComponent</span><span class="p">,</span> <span class="n">yComponent</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">euclidean_unit_vector</span><span class="p">(</span><span class="n">transform_vector</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">euclidean_normal_vector</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span></div>


<div class="viewcode-block" id="minkowski_normal_values"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.minkowski_normal_values">[docs]</a><span class="k">def</span> <span class="nf">minkowski_normal_values</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create x- and y-values for the Minkowski normal vector of the given function.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-coordinates.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function for which the values of the unit normal vectors are created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple </span>
<span class="sd">            The x- and y-values of the normal vector of the given function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span>
    <span class="c1"># check if function is constant</span>
    <span class="k">if</span> <span class="n">isfloat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">xComponent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">)]</span>
        <span class="n">yComponent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">)]</span>
        <span class="n">xComponent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xComponent</span><span class="p">)</span>
        <span class="n">yComponent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yComponent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xComponent</span><span class="p">,</span> <span class="n">yComponent</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">minkowski_unit_vector</span><span class="p">(</span><span class="n">transform_vector</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">minkowski_normal_vector</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span></div>


<div class="viewcode-block" id="euclidean_norm"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.euclidean_norm">[docs]</a><span class="k">def</span> <span class="nf">euclidean_norm</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates Euclidean norm of 2 dimensional vector.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : tuple</span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Euclidean norm of the given vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">radicand</span> <span class="o">=</span> <span class="n">v0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v1</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">radicand</span> <span class="o">=</span> <span class="n">radicand</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radicand</span><span class="p">)</span></div>


<div class="viewcode-block" id="minkowski_norm"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.minkowski_norm">[docs]</a><span class="k">def</span> <span class="nf">minkowski_norm</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates Minkowski norm of 2 dimensional vector with (+-) signature.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : tuple</span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Minkowski norm of the given vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">radicand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v0</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">v1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Norm is infinite.&#39;</span><span class="p">)</span>
    <span class="n">radicand</span> <span class="o">=</span> <span class="n">radicand</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radicand</span><span class="p">)</span></div>


<div class="viewcode-block" id="euclidean_unit_vector"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.euclidean_unit_vector">[docs]</a><span class="k">def</span> <span class="nf">euclidean_unit_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize 2 dimensional vector from Euclidean space.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : tuple</span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Normalized components of the given vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">euclidean_norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span></div>


<div class="viewcode-block" id="minkowski_unit_vector"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.minkowski_unit_vector">[docs]</a><span class="k">def</span> <span class="nf">minkowski_unit_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize 2 dimensional vector from Minkowski space.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : tuple</span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Normalized components of the given vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">minkowski_norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">norm</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span></div>
        

<div class="viewcode-block" id="euclidean_inner_product"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.euclidean_inner_product">[docs]</a><span class="k">def</span> <span class="nf">euclidean_inner_product</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the Eucldiean inner product of two 2 dimensional vectors.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : tuple </span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        w : tuple</span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float </span>
<span class="sd">            Inner product of v and w.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="minkowski_inner_product"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.minkowski_inner_product">[docs]</a><span class="k">def</span> <span class="nf">minkowski_inner_product</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the Minkowski inner product of two 2 dimensional vectors.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : tuple </span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        w : tuple</span>
<span class="sd">            Vector with two components.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float </span>
<span class="sd">            Inner product of v and w.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="reverse_sublist"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.reverse_sublist">[docs]</a><span class="k">def</span> <span class="nf">reverse_sublist</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reverses sublist of given list</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lst : list</span>
<span class="sd">            List where sublist is reversed.</span>
<span class="sd">        start : integer</span>
<span class="sd">            Index where sublist starts.</span>
<span class="sd">        end : integer</span>
<span class="sd">            Index where sublist ends.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lst</span>
<span class="sd">            List where sublist is reversed.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lst</span></div>


<div class="viewcode-block" id="curvature"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.curvature">[docs]</a><span class="k">def</span> <span class="nf">curvature</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate signed curvature of the given function.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function of which the curvature is calculated.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SymPy type </span>
<span class="sd">            Signed curvature of given function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">funcPrime</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
    <span class="n">func2Prime</span> <span class="o">=</span> <span class="n">funcPrime</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">func2Prime</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">funcPrime</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">k</span></div>


<div class="viewcode-block" id="extrema"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.extrema">[docs]</a><span class="k">def</span> <span class="nf">extrema</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds extrem points of function.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interval : tuple</span>
<span class="sd">            Interval limits in which extrema are searched for.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function of which the extram are determined.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Roots of first derivative of the given function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">funcPrime</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
    <span class="n">npFuncPrime</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">funcPrime</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">cr</span> <span class="o">=</span> <span class="n">ClassRoots</span><span class="p">()</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="n">cr</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">npFuncPrime</span><span class="p">,</span> <span class="o">*</span><span class="n">interval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">roots</span></div>


<div class="viewcode-block" id="osculating_circle"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.osculating_circle">[docs]</a><span class="k">def</span> <span class="nf">osculating_circle</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the radius and center of the osculating circles of a function at a given point.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : tuple</span>
<span class="sd">            The x- and y-coordinate of the point of a function at which the osculating circle is calculated.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function for which the osuclating circle is calculated at the given point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Radius and x- and y-coordinate of center of the osculating circle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">point</span>
    <span class="k">if</span> <span class="n">isfloat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span> <span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    <span class="n">funcPrime</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
    <span class="n">func2Prime</span> <span class="o">=</span> <span class="n">funcPrime</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
    <span class="n">npFuncPrime</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">funcPrime</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">npFunc2Prime</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func2Prime</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">npFunc2Prime</span><span class="p">(</span><span class="n">px</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">px</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">npFunc2Prime</span><span class="p">(</span><span class="n">px</span><span class="p">))</span>
        <span class="n">kx</span> <span class="o">=</span> <span class="n">px</span> <span class="o">-</span> <span class="p">(</span><span class="n">npFuncPrime</span><span class="p">(</span><span class="n">px</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">px</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">npFunc2Prime</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
        <span class="n">ky</span> <span class="o">=</span> <span class="n">py</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">px</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">npFunc2Prime</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span></div>


<div class="viewcode-block" id="push_surface"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.push_surface">[docs]</a><span class="k">def</span> <span class="nf">push_surface</span><span class="p">(</span><span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVector</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Push initial surface along normals.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initialSurface : tuple</span>
<span class="sd">            The x- and y-coordinates of the initial 1-surface.</span>
<span class="sd">        unitNormalVector : tuple</span>
<span class="sd">            The x- and y-coordinates of the unit normal vectors of the initial surface.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The x- and y-coordinates of the surface pushed along the normals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">isx</span><span class="p">,</span> <span class="n">isy</span> <span class="o">=</span> <span class="n">initialSurface</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">unitNormalVector</span>
    <span class="n">isx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">isx</span><span class="p">)</span>
    <span class="n">isy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">isy</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">xSigma_s</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">isx</span>
    <span class="n">ySigma_s</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">isy</span>
    <span class="k">return</span> <span class="n">xSigma_s</span><span class="p">,</span> <span class="n">ySigma_s</span></div>

<span class="c1"># the following two methods &#39;intersection&#39; and &#39;calculate_self_intersection&#39; are adapted from </span>
<span class="c1"># https://stackoverflow.com/questions/65532031/how-to-find-number-of-self-intersection-points-on-2d-plot</span>

<div class="viewcode-block" id="intersection"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.intersection">[docs]</a><span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the point where two lines constructed from 4 points intersect.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : float</span>
<span class="sd">            The x-coordinate of a point in 2 dimensional space.</span>
<span class="sd">        yi : float</span>
<span class="sd">            The y-coordinate of a point in 2 dimensional space.</span>

<span class="sd">        Returns </span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The x- and y-coordinate of the point where the two lines intersect.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y3</span><span class="o">-</span><span class="n">y4</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x3</span><span class="o">-</span><span class="n">x4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="p">((</span><span class="n">x1</span><span class="o">*</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="o">*</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x3</span><span class="o">-</span><span class="n">x4</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x3</span><span class="o">*</span><span class="n">y4</span><span class="o">-</span><span class="n">y3</span><span class="o">*</span><span class="n">x4</span><span class="p">))</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">((</span><span class="n">x1</span><span class="o">*</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="o">*</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y3</span><span class="o">-</span><span class="n">y4</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x3</span><span class="o">*</span><span class="n">y4</span><span class="o">-</span><span class="n">y3</span><span class="o">*</span><span class="n">x4</span><span class="p">))</span> <span class="o">/</span> <span class="n">d</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xs</span> <span class="o">&gt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">xs</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">xs</span> <span class="o">&gt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">)</span> <span class="ow">and</span> <span class="n">xs</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span></div>


<div class="viewcode-block" id="calculate_self_intersections"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.calculate_self_intersections">[docs]</a><span class="k">def</span> <span class="nf">calculate_self_intersections</span><span class="p">(</span><span class="n">surface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find all the points where a 1-surface self-intersects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surface : tuple</span>
<span class="sd">            x- and y-coordinates of some surface in 2 dimensional space.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            x- and y-coordinates of self-intersections.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">nsx</span><span class="p">,</span> <span class="n">nsy</span> <span class="o">=</span> <span class="n">surface</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nsx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xs_ys</span> <span class="o">:=</span> <span class="n">intersection</span><span class="p">(</span><span class="n">nsx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nsx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">nsx</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">nsx</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">nsy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nsy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">nsy</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">nsy</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs_ys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs_ys</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span></div>


<div class="viewcode-block" id="parameter_self_intersection"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.parameter_self_intersection">[docs]</a><span class="k">def</span> <span class="nf">parameter_self_intersection</span><span class="p">(</span>
        <span class="n">xValues</span><span class="p">,</span>
        <span class="n">func</span><span class="p">,</span>
        <span class="n">numberOfSurfaces</span><span class="p">,</span> 
        <span class="n">spacing</span><span class="p">,</span> 
        <span class="n">initialSurface</span><span class="p">,</span> 
        <span class="n">unitNormalVector</span><span class="p">,</span> 
        <span class="n">direction</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns list of parameter intervals of the swallow tails of the surfaces </span>
<span class="sd">        obtained by pushing the initial surface along the normals. </span>
<span class="sd">       </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently this does not generally work, e.g., for the exponential function, </span>
<span class="sd">        because there the swallow tails are tilted. This does also not work when </span>
<span class="sd">        the swallow tails get so large that they intersect another swallow tail.</span>
<span class="sd">        Also, if some swallow tail is only partly drawn, in the sense that the point of </span>
<span class="sd">        self-intersection is not included, then the swallow tail will still be visible.</span>
<span class="sd">        In that case it advised to reduce the number of surfaces drawn by one.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-coordinates.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function that characterizes the initial surface.</span>
<span class="sd">        numberOfSurfaces : integer</span>
<span class="sd">            Number of surfaces that are drawn.</span>
<span class="sd">        spacing : integer</span>
<span class="sd">            The distance between two surfaces is by standard 1. </span>
<span class="sd">            Using this parameter the distance can be scaled as 1 / spacing.</span>
<span class="sd">        initialSurface : tuple</span>
<span class="sd">            The x- and y-coordinates of initial surface.</span>
<span class="sd">        unitNormalVector : tuple</span>
<span class="sd">            The x- and y-coordinates of normal vectors of initial surface.</span>
<span class="sd">        direction : integer</span>
<span class="sd">            Is either +1 or -1 depending on direction in which the initial surfaces is pushed along the normals.</span>
<span class="sd">        metric : boolean</span>
<span class="sd">            If True, then use Euclidean metric, else use Minkowski metric.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Parameter intervals of swallow tails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">allTailIntervals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">npF</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">numberOfSurfaces</span> <span class="o">/</span> <span class="n">spacing</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">direction</span>
    <span class="n">newSurface</span> <span class="o">=</span> <span class="n">push_surface</span><span class="p">(</span><span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVector</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">calculate_self_intersections</span><span class="p">(</span><span class="n">newSurface</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ys</span><span class="p">:</span> <span class="k">return</span> <span class="p">[[</span><span class="n">nan</span><span class="p">,</span> <span class="n">nan</span><span class="p">]]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">):</span> <span class="n">lengthSelfInts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
    
    <span class="c1"># Create list of intervals of parameters that parametrize the swallow tail</span>
    <span class="c1"># this is done for every point where the surface self-intersects, because there the swallow tails start</span>
    <span class="c1"># Assumption: The swallow tails are not tilted and do not intersect another swallow tail of the same surface.</span>
    <span class="c1"># Procedure: </span>
    <span class="c1"># 1) Find the point where the surface self-intersects</span>
    <span class="c1"># 2) Consider only points of the surface that lie in a region 0.02 to the left and 0.02 to the right of point of self-intersection</span>
    <span class="c1"># 2.1) Note that x-values are always 0.01 apart from one another.</span>
    <span class="c1"># 3) Consider only points that lie above or below the swallow tail depending on how it is oriented</span>
    <span class="c1"># 3.1) Euclidean Case: For s &gt; 0 the swallow tail is &quot;below&quot; the surface and for s &lt; 0 it is &quot;above&quot; the surface</span>
    <span class="c1"># 3.2) Minkowski Case: For s &lt; 0 the swallow tails is &quot;above&quot; the surface and for s &lt; 0 it is &quot;below&quot; the surface</span>
    <span class="c1"># 4) Divide the remaining points into points that lie to the left and to the right of the self-intersection</span>
    <span class="c1"># 5) Take the largest x-value of the points to the left of the self-intersection and the smallest x-value</span>
    <span class="c1">#    of the points to the right of the self-intersection. These are the x-values that define the parameter</span>
    <span class="c1">#    interval of the swallow tail.</span>

    <span class="c1"># Orientation determines whether tail is &quot;above&quot; surface or &quot;below&quot;.</span>
    <span class="n">orientation</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">metric</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">orientation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">orientation</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">orientation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">orientation</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lengthSelfInts</span><span class="p">):</span>
        <span class="n">tailInterval</span><span class="p">,</span> <span class="n">leftxValue</span><span class="p">,</span> <span class="n">rightxValue</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xValue</span> <span class="ow">in</span> <span class="n">xValues</span><span class="p">:</span>
            <span class="n">xCopy</span> <span class="o">=</span> <span class="n">xValue</span>
            <span class="n">xValue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">xValue</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">metric</span><span class="p">:</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="n">euclidean_normal_values</span><span class="p">(</span><span class="n">xValue</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="n">minkowski_normal_values</span><span class="p">(</span><span class="n">xValue</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">xValue</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">npF</span><span class="p">(</span><span class="n">xValue</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">nx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.02</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">leftxValue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xCopy</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rightxValue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xCopy</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ny</span> <span class="o">&lt;=</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">leftxValue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xCopy</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rightxValue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xCopy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">leftxValue</span> <span class="ow">and</span> <span class="n">rightxValue</span><span class="p">:</span>
            <span class="n">tailInterval</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">leftxValue</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rightxValue</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">tailInterval</span> <span class="o">=</span> <span class="p">[</span><span class="n">nan</span><span class="p">,</span> <span class="n">nan</span><span class="p">]</span>
        <span class="n">allTailIntervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tailInterval</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">allTailIntervals</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">allTailIntervals</span>         </div>


<div class="viewcode-block" id="draw_extrema"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_extrema">[docs]</a><span class="k">def</span> <span class="nf">draw_extrema</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draws points where given function has extrema.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interval : list</span>
<span class="sd">            First entry is lower interval limit and second entry is uper interval limit. </span>
<span class="sd">            This gives the interval in which extrema are searched for.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function for which the extrema are searched for.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">extrema</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Extrema: &#39;</span><span class="p">,</span> <span class="n">roots</span><span class="p">)</span>
    <span class="n">npFunc</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">npFunc</span><span class="p">(</span><span class="n">roots</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="draw_curvature"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_curvature">[docs]</a><span class="k">def</span> <span class="nf">draw_curvature</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draws signed curvature.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-coordinates.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function of which the curvature is drawn.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if function is constant</span>
    <span class="k">if</span> <span class="n">isfloat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">curv</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xValues</span><span class="p">]</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">curv</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># if function is linear</span>
    <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">degree</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">curv</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xValues</span><span class="p">]</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">curv</span><span class="p">)</span>
            <span class="k">return</span>
    <span class="c1"># all other cases</span>
    <span class="n">curv</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">curvature</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">curv</span><span class="p">(</span><span class="n">xValues</span><span class="p">))</span></div>


<div class="viewcode-block" id="draw_centers_osc_circ"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_centers_osc_circ">[docs]</a><span class="k">def</span> <span class="nf">draw_centers_osc_circ</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">xValues</span><span class="p">,</span> <span class="n">connectedCircles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draw centers of osculating circles and print the minimal radius from all osculating circles,</span>
<span class="sd">        the point at which the radius is minimal and the corresponding center of the osculating circle.</span>
<span class="sd">        The printed values are rounded to three decimal places.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Only centers with x- and y-value smaller than the calculated xmax and ymax value are drawn.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surface : tuple</span>
<span class="sd">            The x- and y-coordinates of the given surface of which the osculating circles are calculated.</span>
<span class="sd">        func : SymPy type</span>
<span class="sd">            Function that characterizes the given surface.</span>
<span class="sd">        valueLimit : integer</span>
<span class="sd">            Maximal x-value, which is used to determine the largest allowed value for the x- and y-coordinate</span>
<span class="sd">            of the centers of osculating circles that will still be drawn.</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-Values.</span>
<span class="sd">        connectedCircles : boolean</span>
<span class="sd">            If True the centers of osculating circles are plotted with the plot function, which yields a connected line. </span>
<span class="sd">            Otherwise they are ploted with the scatter function, which gives separate points. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kx_surf</span><span class="p">,</span> <span class="n">ky_surf</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">npF</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">npF</span><span class="p">(</span><span class="n">xValues</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">surface</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">point</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">npF</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span> <span class="o">=</span> <span class="n">osculating_circle</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">xmax</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ky</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ymax</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ky</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kx_surf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kx</span><span class="p">)</span>
                <span class="n">ky_surf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ky</span><span class="p">)</span>
                <span class="n">radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
    <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">minRadius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Minimal Radius of Osculating Circles: &#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">minRadius</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Point of minimal Radius: (&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="s1">&#39;)&#39;</span> <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Corresponding Center of Osculating Circle: (&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">kx_surf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">ky_surf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># raised if radii is empty</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No Radii could be calculated.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">connectedCircles</span><span class="p">:</span>
        <span class="c1">#ax1.plot(kx_surf, ky_surf, color=&#39;green&#39;, label=&#39;Centers of Osculating Circles&#39;)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kx_surf</span><span class="p">,</span> <span class="n">ky_surf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Focal Locus&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">kx_surf</span><span class="p">,</span> <span class="n">ky_surf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Centers of Osculating Circles&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></div>
 

<div class="viewcode-block" id="draw_normics"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_normics">[docs]</a><span class="k">def</span> <span class="nf">draw_normics</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="n">normicSpacing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draws the normal lines of the initial surface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : list</span>
<span class="sd">            Values for which the normal line is drawn along the normal starting from the initial surface.</span>
<span class="sd">        initialSurface : tupel </span>
<span class="sd">            The x- and y-coordinates of the initial surface.</span>
<span class="sd">        unitNormalVectors : tupel</span>
<span class="sd">            The x- and y-coordinates of the unit normal vectors of the initial surface.</span>
<span class="sd">        normicSpacing : integer</span>
<span class="sd">            Only every n-th element of the lists of coordinates is used to draw the normal lines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">isx</span><span class="p">,</span> <span class="n">isy</span> <span class="o">=</span> <span class="n">initialSurface</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">unitNormalVectors</span>
    <span class="n">isx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">isx</span><span class="p">)</span>
    <span class="n">isy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">isy</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">nx</span><span class="p">[::</span><span class="n">normicSpacing</span><span class="p">]</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">ny</span><span class="p">[::</span><span class="n">normicSpacing</span><span class="p">]</span>
    <span class="n">isx</span> <span class="o">=</span> <span class="n">isx</span><span class="p">[::</span><span class="n">normicSpacing</span><span class="p">]</span>
    <span class="n">isy</span> <span class="o">=</span> <span class="n">isy</span><span class="p">[::</span><span class="n">normicSpacing</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span> <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">normal_x</span> <span class="o">=</span> <span class="n">nx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">isx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">normal_y</span> <span class="o">=</span> <span class="n">ny</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">isy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">normal_x</span><span class="p">,</span> <span class="n">normal_y</span><span class="p">)</span></div>


<div class="viewcode-block" id="draw_tangents"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_tangents">[docs]</a><span class="k">def</span> <span class="nf">draw_tangents</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draws the tangent vector to a surface. </span>
<span class="sd">        </span>
<span class="sd">        Note</span>
<span class="sd">        -----</span>
<span class="sd">        It might look like the tangent vector is not actually tangent. </span>
<span class="sd">        This is due to scaling of the plot and is something that has to be fixed. </span>
<span class="sd">       </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xValues : list</span>
<span class="sd">            List of x-coordinates.</span>
<span class="sd">        func : SymPy expression</span>
<span class="sd">            Function of which the tangent vector is calculated.</span>
<span class="sd">        s : float</span>
<span class="sd">            Parameter value of the surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">funcPrime</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">func2Prime</span> <span class="o">=</span> <span class="n">funcPrime</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">npFunc</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">npFuncPrime</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">funcPrime</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">npFunc2Prime</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func2Prime</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># signed curvature</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">npFunc2Prime</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="c1"># critical coefficient</span>
    <span class="n">A</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span>  <span class="n">k</span> <span class="o">*</span> <span class="n">s</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">A</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="o">-</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">xValues</span> 
    <span class="n">yc</span> <span class="o">=</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">npFuncPrime</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">npFunc</span><span class="p">(</span><span class="n">xValues</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">c1</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">c2</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span></div>


<div class="viewcode-block" id="draw_surfaces"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_surfaces">[docs]</a><span class="k">def</span> <span class="nf">draw_surfaces</span><span class="p">(</span><span class="n">numberOfSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">sameSurfaceColor</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">cnorm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draws the surfaces that arise when pushing the initial surface along the normal lines.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        numberOfSurfaces : integer</span>
<span class="sd">            The number of Surfaces that are drawn.</span>
<span class="sd">        spacing : integer</span>
<span class="sd">            The distance between two surfaces is by standard 1. </span>
<span class="sd">            Using this parameter the distance can be scaled as 1 / spacing.</span>
<span class="sd">        initial surface : tuple</span>
<span class="sd">            The x- and y-coordinates of the initial surface.</span>
<span class="sd">        unitNormalVectors : tuple</span>
<span class="sd">            The x- and y-coorindates of the unit normal vectors of the initial surface.</span>
<span class="sd">        direction : integer</span>
<span class="sd">            Is either +1 or -1 depending on direction in which the initial surfaces is pushed along the normals.</span>
<span class="sd">        sameSurfaceColor : boolean</span>
<span class="sd">            Whether the surfaces are drawn with the same color or with individual colors.</span>
<span class="sd">        cmap : matplotlib.colors.LinearSegmentedColormap</span>
<span class="sd">        cnorm : matplotlib.colors.Normalize</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numberOfSurfaces</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">sameSurfaceColor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">cnorm</span><span class="p">(</span><span class="n">direction</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">cnorm</span><span class="p">(</span><span class="n">direction</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">spacing</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">direction</span>
        <span class="n">newSurface</span> <span class="o">=</span> <span class="n">push_surface</span><span class="p">(</span><span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">newSurface</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;s = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span></div>


<div class="viewcode-block" id="draw_modified_surfaces"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_modified_surfaces">[docs]</a><span class="k">def</span> <span class="nf">draw_modified_surfaces</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> 
        <span class="n">valueLimit</span><span class="p">,</span> 
        <span class="n">numberOfSurfaces</span><span class="p">,</span> 
        <span class="n">spacing</span><span class="p">,</span> 
        <span class="n">initialSurface</span><span class="p">,</span> 
        <span class="n">unitNormalVectors</span><span class="p">,</span> 
        <span class="n">direction</span><span class="p">,</span> 
        <span class="n">sameSurfaceColor</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">,</span>
        <span class="n">cmap</span><span class="p">,</span>
        <span class="n">cnorm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draws modified surfaces, that is the surfaces where the swallow tail is removed. </span>
<span class="sd">        It also prints the parameter interval of the swallow tails that are drawn.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : SymPy expression</span>
<span class="sd">            Function that characterizes the initial surface.</span>
<span class="sd">        valueLimit : integer</span>
<span class="sd">            Value for left and right interval limit for the x-coordinates.</span>
<span class="sd">        numberOfSurfaces : integer</span>
<span class="sd">            The number of Surfaces that are drawn.</span>
<span class="sd">        spacing : integer</span>
<span class="sd">            The distance between two surfaces is by standard 1. </span>
<span class="sd">            Using this parameter the distance can be scaled as 1 / spacing.</span>
<span class="sd">        initialSurface : tuple</span>
<span class="sd">            The x- and y-coordinates of the initial surface.</span>
<span class="sd">        unitNormalVectors : tuple</span>
<span class="sd">            The x- and y-coorindates of the unit normal vectors of the initial surface.</span>
<span class="sd">        direction : integer</span>
<span class="sd">            Is either +1 or -1 depending on direction in which the initial surfaces is pushed along the normals.</span>
<span class="sd">        sameSurfaceColor : boolean</span>
<span class="sd">            Whether the surfaces are drawn with the same color or with individual colors.</span>
<span class="sd">        metric : boolean</span>
<span class="sd">            If True, then use Euclidean metric, else use Minkowski metric.</span>
<span class="sd">        cmap : matplotlib.colors.LinearSegmentedColormap</span>
<span class="sd">        cnorm : matplotlib.colors.Normalize</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numberOfSurfaces</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">xValues_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">valueLimit</span><span class="p">,</span> <span class="n">valueLimit</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>  
        <span class="k">if</span> <span class="n">sameSurfaceColor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">cnorm</span><span class="p">(</span><span class="n">direction</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">cnorm</span><span class="p">(</span><span class="n">direction</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">spacing</span>
        <span class="n">allTailIntervals</span> <span class="o">=</span> <span class="n">parameter_self_intersection</span><span class="p">(</span><span class="n">xValues_mod</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
        <span class="c1"># modify parameter interval</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">allTailIntervals</span><span class="p">)):</span>
            <span class="n">tailInterval</span> <span class="o">=</span> <span class="n">allTailIntervals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tail interval: [&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">tailInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">tailInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tailInterval</span> <span class="ow">and</span> <span class="n">tailInterval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nan</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tailInterval</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tailInterval</span><span class="p">)):</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xValues_mod</span><span class="p">)):</span>
                            <span class="k">if</span>  <span class="n">xValues_mod</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tailInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">xValues_mod</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tailInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">xValues_mod</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">metric</span><span class="p">:</span>
                <span class="n">newNormics</span> <span class="o">=</span> <span class="n">euclidean_normal_values</span><span class="p">(</span><span class="n">xValues_mod</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newNormics</span> <span class="o">=</span> <span class="n">minkowski_normal_values</span><span class="p">(</span><span class="n">xValues_mod</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="n">newSurface</span> <span class="o">=</span> <span class="n">push_surface</span><span class="p">(</span><span class="n">initialSurface</span><span class="p">,</span> <span class="n">newNormics</span><span class="p">,</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">distance</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">newSurface</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;s = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">distance</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span></div>


<div class="viewcode-block" id="draw_self_intersections"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.draw_self_intersections">[docs]</a><span class="k">def</span> <span class="nf">draw_self_intersections</span><span class="p">(</span><span class="n">numberOfSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Draw all points where evolved surfaces self-intersect and print the x- and y-values of the self-intersection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        numberOfSurfaces : integer</span>
<span class="sd">            The number of Surfaces that are drawn.</span>
<span class="sd">        spacing : integer</span>
<span class="sd">            The distance between two surfaces is by standard 1. </span>
<span class="sd">            Using this parameter the distance can be scaled as 1 / spacing.</span>
<span class="sd">        initialSurface : tuple</span>
<span class="sd">            The x- and y-coordinates of the initial surface.</span>
<span class="sd">        unitNormalVectors : tuple</span>
<span class="sd">            The x- and y-coorindates of the unit normal vectors of the initial surface.</span>
<span class="sd">        direction : integer</span>
<span class="sd">            Is either +1 or -1 depending on direction in which the initial surfaces is pushed along the normals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">numberOfSurfaces</span> <span class="o">/</span> <span class="n">spacing</span>
    <span class="n">newSurface</span> <span class="o">=</span> <span class="n">push_surface</span><span class="p">(</span><span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">distance</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">calculate_self_intersections</span><span class="p">(</span><span class="n">newSurface</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xs</span> <span class="ow">and</span> <span class="n">ys</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x-values of self-intersections: &#39;</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;y-values of self-intersections: &#39;</span><span class="p">,</span>  <span class="n">ys</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Current surface has no self-intersections!&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="save_plot"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.save_plot">[docs]</a><span class="k">def</span> <span class="nf">save_plot</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Saves the current full figure and the first axis as .pdf and .eps in the figures folder which</span>
<span class="sd">        should be located in the same folder as this notebook.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name under which the images are saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># save whole figure as pdf</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;figures/full-&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="c1"># Save just the portion inside the second axis&#39;s boundaries</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
    <span class="c1"># Pad the saved area by 40% in the x-direction and 25% in the y-direction and save as pdf</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;figures/&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="n">extent</span><span class="o">.</span><span class="n">expanded</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">))</span>
    <span class="c1"># save whole figure as eps</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;figures/full-&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.eps&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">1200</span><span class="p">)</span>
    <span class="c1"># Save just the portion inside the second axis&#39;s boundaries</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
    <span class="c1"># Pad the saved area by 40% in the x-direction and 20% in the y-direction and save as eps</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;figures/&#39;</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.eps&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="n">extent</span><span class="o">.</span><span class="n">expanded</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">1200</span><span class="p">)</span></div>


<div class="viewcode-block" id="py_to_tex"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.py_to_tex">[docs]</a><span class="k">def</span> <span class="nf">py_to_tex</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replaces python operators with latex operators.</span>
<span class="sd">        </span>
<span class="sd">        Parameters </span>
<span class="sd">        ----------</span>
<span class="sd">        str : str</span>
<span class="sd">            String python expressions are replaced by the proper latex expressions.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str </span>
<span class="sd">            Modified string.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,</span> <span class="s1">&#39;^&#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">cdot &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">sin &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">cos &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">tan &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;cot&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">cot &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">sinh &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;cosh&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">cosh &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">tanh &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;coth&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">coth &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">exp &#39;</span><span class="p">)</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39; </span><span class="se">\\</span><span class="s1">log &#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">str</span></div>

<div class="viewcode-block" id="drawing"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.drawing">[docs]</a><span class="k">def</span> <span class="nf">drawing</span><span class="p">(</span> 
        <span class="n">inputFunction</span><span class="p">,</span>
        <span class="n">inputSaveFileName</span><span class="p">,</span>
        <span class="n">valueLimit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">numberOfFutureSurfaces</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
        <span class="n">numberOfPastSurfaces</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">spacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
        <span class="n">posXLim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
        <span class="n">negXLim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">posYLim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">negYLim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
        <span class="n">normicSpacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">tangent_xValues</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">showCentersOscCircle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">connectedCenters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">showNormics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">showSurface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">changeLimits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tangentVector</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">showSelfIntersections</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">showTails</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sameSurfaceColor</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">saveFile</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;Is the method regularly called by the interact method.</span>
<span class="sd">        Modifies the initial figure by giving it a title etc., handles the user inputs,</span>
<span class="sd">        controls the different choices,</span>
<span class="sd">        displays the plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputFunction : str</span>
<span class="sd">            User input that is used as the function that characterizes the initial surface.</span>
<span class="sd">        inputSaveFileName : str</span>
<span class="sd">            Name that is used when saving a plot.</span>
<span class="sd">        valueLimit : integer</span>
<span class="sd">            Interval limit for the x-values.</span>
<span class="sd">        numberOfFutureSurfaces : integer</span>
<span class="sd">            Number of surfaces that are drawn into the &#39;future&#39;, i.e., that have direction +1.</span>
<span class="sd">        numberOfPastSurfaces : integer</span>
<span class="sd">            Number of surfaces that are drawn into the &#39;future&#39;, i.e., that have direction -1.</span>
<span class="sd">        spacing : integer</span>
<span class="sd">            The distance between two surfaces is by standard 1. </span>
<span class="sd">            Using this parameter the distance can be scaled as 1 / spacing.</span>
<span class="sd">        posXLim : integer</span>
<span class="sd">            Limit for positive x-axis. </span>
<span class="sd">        negXLim : integer</span>
<span class="sd">            Limit for negative x-axis.</span>
<span class="sd">        posYLim : integer</span>
<span class="sd">            Limit for positive y-axis.</span>
<span class="sd">        negYLim : integer</span>
<span class="sd">            Limit for negative y-axis.</span>
<span class="sd">        normicSpacing : integer</span>
<span class="sd">            Inverse density of normal lines that are drawn. If normicSpacing = n, then only every </span>
<span class="sd">            nth normal line is drawn. </span>
<span class="sd">        tangent_xValues : integer</span>
<span class="sd">            The x-value that parameterizes the surface at which the tangent vector is drawn.</span>
<span class="sd">        showCentersOscCircle : boolean</span>
<span class="sd">            If True the centers of the osculating circles of the initial surface are drawn, </span>
<span class="sd">            otherwise they are not drawn.</span>
<span class="sd">        connectedCircles : boolean</span>
<span class="sd">            If True the centers of osculating circles are plotted with the plot function, which yields a connected line. </span>
<span class="sd">            Otherwise they are ploted with the scatter function, which gives separate points. </span>
<span class="sd">        showNormics : boolean</span>
<span class="sd">            If True the normal lines are drawn, otherwise they are not drawn.</span>
<span class="sd">        showSurface : boolean</span>
<span class="sd">            If True the surfaces that arise from pushing the initial surface along the normal lines</span>
<span class="sd">            are drawn, otherwise they are not drawn.</span>
<span class="sd">        changeLimits : boolean</span>
<span class="sd">            If True the limits of the axes are changed according to the settings of the user, otherwise</span>
<span class="sd">            the axes change according to the size of the plot.</span>
<span class="sd">        tangeVector : boolean</span>
<span class="sd">            If True the tangent vector of a surface at the chosen parameter x-value is drawn, otherwise the tangent</span>
<span class="sd">            vector is not drawn.</span>
<span class="sd">        showSelfIntersections : boolean</span>
<span class="sd">            If True then at the points of self-intersection a red dot is drawn, otherwise no</span>
<span class="sd">            red dots are drawn.</span>
<span class="sd">        showTails : boolean</span>
<span class="sd">            If True the tails of the swallow tails are shown drawn, otherwise they are removed by the draw_modified_surfaces</span>
<span class="sd">            method if possible (see note of that method).</span>
<span class="sd">        sameSurfaceColor : boolean</span>
<span class="sd">            If True all surfaces are drawn with the same color (blue), otherwise every surface has an individual color.</span>
<span class="sd">        saveFile : boolean</span>
<span class="sd">            If True the plot that it shown after pressing the &#39;Run interact&#39; button is saved under the name written in the</span>
<span class="sd">            &#39;Name of Image&#39; textbox.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">titleFunction</span> <span class="o">=</span> <span class="n">py_to_tex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">inputFunction</span><span class="p">))</span>
    <span class="c1"># Settings of figure and axis</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">set_figheight</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">set_figwidth</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Evolution of the initial surface $f(x) = &#39;</span> <span class="o">+</span> <span class="n">titleFunction</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;$.&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Signed curvature $k$&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">minorticks_on</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">changeLimits</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">negXLim</span><span class="p">,</span> <span class="n">posXLim</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">negYLim</span><span class="p">,</span> <span class="n">posYLim</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="n">negXLim</span><span class="p">,</span> <span class="n">posXLim</span><span class="p">)</span>
    <span class="c1"># Create evenly spaced values within a given interval</span>
    <span class="n">xValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">valueLimit</span><span class="p">,</span> <span class="n">valueLimit</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="n">sValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">numberOfPastSurfaces</span> <span class="o">/</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">/</span> <span class="n">spacing</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="c1"># create normalized cmap</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">coolwarm</span>
    <span class="k">if</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cnorm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">numberOfPastSurfaces</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">numberOfPastSurfaces</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">numberOfPastSurfaces</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cnorm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">numberOfFutureSurfaces</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">numberOfFutureSurfaces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cnorm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">numberOfPastSurfaces</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">numberOfFutureSurfaces</span><span class="p">)</span>
    <span class="c1"># Transform text to python expression</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">inputFunction</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># Ignore error that appears when not done writing</span>
        <span class="k">pass</span>
    <span class="n">initialSurface</span> <span class="o">=</span> <span class="n">transform_function</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="c1"># Choice of metric</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$y$&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$k$&#39;</span><span class="p">)</span>
        <span class="n">unitNormalVectors</span> <span class="o">=</span> <span class="n">euclidean_normal_values</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="n">draw_curvature</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="c1"># Choice of drawing the centers of osculating circles</span>
        <span class="k">if</span> <span class="n">showCentersOscCircle</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">draw_centers_osc_circ</span><span class="p">(</span><span class="n">initialSurface</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">xValues</span><span class="p">,</span> <span class="n">connectedCenters</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$k$&#39;</span><span class="p">)</span>
        <span class="n">unitNormalVectors</span> <span class="o">=</span> <span class="n">minkowski_normal_values</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="c1"># Choice of drawing normics</span>
    <span class="k">if</span> <span class="n">showNormics</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">draw_normics</span><span class="p">(</span><span class="n">sValues</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="n">normicSpacing</span><span class="p">)</span>
    <span class="c1"># Draw initial surface</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">initialSurface</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">cnorm</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;s = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">showSurface</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">showTails</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Draw &#39;past&#39; surfaces</span>
            <span class="k">if</span> <span class="n">numberOfPastSurfaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">draw_surfaces</span><span class="p">(</span><span class="n">numberOfPastSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sameSurfaceColor</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">cnorm</span><span class="p">)</span>
            <span class="c1"># Draw &#39;future&#39; surfaces</span>
            <span class="k">if</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">draw_surfaces</span><span class="p">(</span><span class="n">numberOfFutureSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">sameSurfaceColor</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">cnorm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="c1"># Draw modified &#39;past&#39; surfaces</span>
            <span class="k">if</span> <span class="n">numberOfPastSurfaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">draw_modified_surfaces</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">valueLimit</span><span class="p">,</span> <span class="n">numberOfPastSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sameSurfaceColor</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">cnorm</span><span class="p">)</span>    
            <span class="c1"># Draw modified &#39;future&#39; surfaces</span>
            <span class="k">if</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">draw_modified_surfaces</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">valueLimit</span><span class="p">,</span> <span class="n">numberOfFutureSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">sameSurfaceColor</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">cnorm</span><span class="p">)</span>    
    <span class="c1"># Draw tangent vector</span>
    <span class="k">if</span> <span class="n">tangentVector</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">draw_tangents</span><span class="p">(</span><span class="n">tangent_xValues</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">/</span> <span class="n">spacing</span><span class="p">)</span>
    <span class="c1"># Draw red dot where the evolved surface self-intersects</span>
    <span class="k">if</span> <span class="n">showSelfIntersections</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">draw_self_intersections</span><span class="p">(</span><span class="n">numberOfFutureSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numberOfPastSurfaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">draw_self_intersections</span><span class="p">(</span><span class="n">numberOfPastSurfaces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">initialSurface</span><span class="p">,</span> <span class="n">unitNormalVectors</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Create legend only for less than 15 surfaces (else they go beyond the plot and it becomes ugly)</span>
    <span class="k">if</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">+</span> <span class="n">numberOfPastSurfaces</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">:</span>
        <span class="c1"># This snippet of code for creating and sorting the entries of the legend is not written by me, source:</span>
        <span class="c1"># https://stackoverflow.com/questions/22263807/how-is-order-of-items-in-matplotlib-legend-determined</span>
        <span class="c1"># Create legend</span>
        <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
        <span class="c1"># Sort both labels and handles by labels</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">handles</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">handles</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">handles</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numberOfPastSurfaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># reverse order of negative s labels</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">handles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">reverse_sublist</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">numberOfFutureSurfaces</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">+</span> <span class="n">numberOfPastSurfaces</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">handles</span> <span class="o">=</span> <span class="n">reverse_sublist</span><span class="p">(</span><span class="n">handles</span><span class="p">,</span> <span class="n">numberOfFutureSurfaces</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">numberOfFutureSurfaces</span> <span class="o">+</span> <span class="n">numberOfPastSurfaces</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>

    <span class="c1"># Save plots</span>
    <span class="k">if</span> <span class="n">saveFile</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">inputSaveFileName</span><span class="p">)</span>
        <span class="n">save_plot</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        
    <span class="c1"># Display figure</span>
    <span class="n">display</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span></div>

<div class="viewcode-block" id="main"><a class="viewcode-back" href="../foliationSimulation.html#foliationSimulation.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Style such that whole text fits</span>
    <span class="n">style</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;description_width&#39;</span><span class="p">:</span> <span class="s1">&#39;initial&#39;</span><span class="p">}</span>
    <span class="n">interact_manual</span><span class="p">(</span><span class="n">drawing</span><span class="p">,</span>
        <span class="n">valueLimit</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Max. x-Value:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span> 
        <span class="n">inputFunction</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
            <span class="n">placeholder</span><span class="o">=</span><span class="s1">&#39;Initial Function, e.g. x**2&#39;</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Initial Function: &#39;</span><span class="p">,</span>
            <span class="n">disabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">style</span>
        <span class="p">),</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">RadioButtons</span><span class="p">(</span>
            <span class="n">options</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Euclidean&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Minkowski&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)],</span>
            <span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Metric: &#39;</span><span class="p">,</span>
            <span class="n">disabled</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">),</span>            
        <span class="n">numberOfFutureSurfaces</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;N Future Surfaces:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span> 
        <span class="n">numberOfPastSurfaces</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;N Past Surfaces:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Inverse Thickness:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>  
        <span class="n">normicSpacing</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Inverse Normic Density:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">posXLim</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Pos. x Limit:&#39;</span><span class="p">,</span> <span class="n">sytle</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">negXLim</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Neg. x Limit:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">posYLim</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Pos. y Limit:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">negYLim</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Neg. y Limit:&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">tangent_xValues</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">FloatSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=-</span><span class="mi">5</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">showCentersOscCircle</span> <span class="o">=</span>  <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Show Centers of Osculating Circle&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">connectedCenters</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Draw connected Centers&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">showNormics</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Show Normics&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">showSurface</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Show Evolved Surfaces&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">changeLimits</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Change Axis Limits&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">tangentVector</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Show Tangent Vector&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">showSelfIntersections</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Show Points of Self-Intersection&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">showTails</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Show Swallow Tails&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">sameSurfaceColor</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;All Surfaces same Color&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">saveFile</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Save File&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">),</span>
        <span class="n">inputSaveFileName</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span>
            <span class="n">placeholder</span><span class="o">=</span><span class="s1">&#39;Insert Name of Image&#39;</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Name of Image&#39;</span><span class="p">,</span>
            <span class="n">disabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">style</span>
        <span class="p">),</span>
    <span class="p">)</span></div>
    
<span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Florian Babisch.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>